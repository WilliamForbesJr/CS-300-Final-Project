# CS-300-Final-Project

## Problem
The problem that we were solving with the projects in this course was to take a set of course data from a .csv file and load its content into an application. This application needed to efficiently load the data, search the data, and validate that the data provided matched the schema outlined in the specs. In order to ensure that the application could maintain efficiency at scale, the appropriate data structure needed to be selected by analyzing each possible structure and comparing each strength and drawback for this implementation. 

## Approach
My approach to this problem was to first breakdown the current specifications and then extrapolate future implementations for this application such as new potential features and scalability for larger data sets. Following that, I took the time to create detailed pseudocode for each data structure (tree, hash table, linked list, and vector) to gain an understanding as to how the implementation would be with each. The details that I looked for were performance, extensibility, and complexity. During comparison if two data structures performed similarly, then the structure that was easier to extend and less complex to maintain and analyze would be chosen. In the end, I decided to use a hash table for the main data structure of the application due to the fact that each course had a unique identifier that can serve as its key and the quick lookup performance that a hash table provides. The drawback to using a hash table versus a linked list, vector, or tree is that it uses unordered data. However, the quick lookup capabilities used in operations such as validating prerequisite data and searching outweighed the drawback of needing to perform an additional operation to order the provided data.


## Reflection
The main drawback I encountered during the project was centered around chaining and handling collisions within a hash table. I did not initially properly handle chaining nor did I account for collisions when searching and printing data. If there was a collision, that value should be set as the node's next value. While my initial implementation handled that aspect, I failed to traverse the nodes and check for the next value which caused those values to be unsearchable to the user. It wasn't until more extensive tests were provided that I was able to catch the issue and properly debug it.

This project absolutely helped me improve a broad set of skills. I feel that this work has given me much better understanding of how hash tables and trees are created. In my experience with other languages, a lot of the hash table logic is abstracted away when working with something like an object in JavaScript, or an associative array in PHP. This was a great experience in being able to understand more of the implementation details of how that logic works. I also improved my abilities when working with C++, specifically around using pointers and references. From a design standpoint, I really liked the exercise of trying to implement every data structure for the same problem, even if it didn't initially seem to be the strongest fit. This helped stretch my imagination since it forced me to use a structure that I may have initially discounted which ended up requiring a little more creativity when designing the program with that structure. Overall, this has been a great learning experience!
